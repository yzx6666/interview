1.什么是协程？
	协程是一种比线程更轻量级的存在，完全由程序员控制，只有用户态。一个线程中可以有多个协程，协程是串行的，线程中某一个协程运行时，其他协程必须挂起，这与线程/进程不同，线程/进程在多核CPU可以并行。

2.查看CPU状态？ 
	top，若CPU使用率过高，可能还需要优化程序算法、减少不必要的计算或增加CPU资源

3.linux下，在使用rm删除正在写入的文件会怎么样？ 
	导致数据丢失或损坏。因为rm命令会立刻删除文件系统中的引用，而正在写入的文件可能还有为写入磁盘的缓存数据。

4.查看磁盘空间？ 
	df -h，如果磁盘已满，需要及时清理不必要的文件或扩展磁盘容量

5.数据库三范式，范式解决了什么问题，为什么要三范式？
	1.第一范式：强调的是列的原子性，即每一列都是不可再分的最小数据单元。
	2.第二范式：满足第一范式，表必须有一个主键，对于非主键的其他列必须完全依赖于主键，而不能只依赖于主键的一部分。
	3.第三范式：满足第二范式，非主键列必须直接依赖于主键，不能存在传递依赖。
	解决了：消除重复数据减少冗余数据，从而让数据库内的数据能划分的更合理。消除潜在的异常

6.左值和右值？
	可以取地址，有名字的就是左值，不可以取地址，没有名字的就是右值。右值分为纯右值和将亡值，纯右值是临时变量和字面值，将忘值是返回右值引用的函数的返回值，move的返回值。
	左值引用是对左值的引用，右值引用是对右值的引用，引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去。

7.malloc的底层系统调用？
	方式一：用户分配的内存小于 128 KB，通过 brk() 系统调用从堆分配内存，
	方式二：用户分配的内存大于 128 KB，通过 mmap() 系统调用在文件映射区域分配内存；
	因为mmap申请的内存释放时要返回给操作系统，所以每次都要重新使用系统调用，并且第一次访问的时候还会缺页中断，会导致CPU消耗过大，而brk()是在堆上申请内存，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中，但是brk容易产生内存碎片导致出现越来越多的不可用碎片。

8.free/delete为什么不需要指定大小？
	malloc分配内存时，真实申请的内存会比实际的大（原因：字节对齐和返回的指针前有一段头部信息一般16字节，里面有申请的内存大小），free时，会向前偏移就会得到申请内存的大小，去释放内存。

9.weak ptr怎么知道shared ptr的引用计数为0了？ 
	use_count()会返回对象的强引用计数的个数，或者使用lock，当引用计数大于0，会转换成shared_ptr并且引用计数会加一，否则会返回空指针。

10.C语言和C++ 结构体区别？
	1.C语言中的结构体不能包含成员函数，而C++中的结构体可以包含成员函数，甚至可以是虚函数
	2.C语言中的结构体只有public访问权限，而C++中的结构体可以有public、private、protected三种访问权限
	3.C语言中的结构体不支持继承，而C++中的结构体可以从类或其他结构体继承，也可以继承给其他类
	4.C结构体的空结构体sizeof为0，C++的sizeof为1
	5.C结构体在定义时除非使用typedef，否则之后定义变量都必须跟上struct + 结构体名，而C++结构体可以直接使用结构体名，不需要加struct。

11.C 语言如何实现面向对象？
	可以通过结构体实现封装，通过函数指针实现继承和多态，函数重载可以使用类似printf函数的可变参数实现。

12.缺页中断时发生了什么？
	会先查找该页面在磁盘页面中的位置，然后在从物理内存找空闲页，找到了直接换入物理内存中，否则要进行页面置换
	页面置换算法： FIFO先进先出置换算法 、OPT最佳页面置换算法、LRU最近最久未使用置换算法、LFU最不常用算法

13.索引下推？
	可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
	比如建立（a，b）联合索引，查询条件为a>1 and b = 2,这样只会在a > 1时，用到索引。如果没有索引下推的话，会将查询到的主键进行回表，将完整的数据返回给server层，然后server进行判断。使用索引下推就不会直接回表，而是先判断条件是否成立，如果不成立直接跳过该索引。

14. linux命令 怎么搜索系统中的大文件
	1. 使用find ： find -size +xx 寻找大小大于xx的文件
	2. 使用du(磁盘使用) ： du -ah | sort -rh | head -n 10 查找最大的 10 个文件，
			 -a所有的，-h人类方便看的，-r逆序，-n 显示xx行

      linux命令 查看文件前100行，找出以text结尾的
	head -n 100 filename | grep "text$" 显示100行并以text结尾 “text$”

15. const修饰的变量存在哪里？
	只读数据段 .rdata

16.使用using 和 typedef 的区别？ 
			using可读性更好，可以用作模板别名
			template<typename T>
			using MyVector = std::vector<T>;

17.函数入栈的顺序，为什么？ 
	从右向左入栈，因为要知道函数参数的个数

18.删除表的方式有哪几种
	1.delete ：删除一行或多行数据，支持回滚数据
	2.Truncate：删除表中的所有数据，但是保留表的结构，不支持回滚
	3.Drop：删除表的所有数据和索引，不支持回滚
	当不需要一个表时，用drop。当需要删除所有数据但保留表结构时，用truncate。当要删除一些数据时，用delete。

19.用户态和内核态的区别，什么时候在用户态，什么时候在内核态，用户态什么时候切换到内核态，怎么返回用户态
	区别：处于用户态执行的程序，进程所能访问的内存空间和对象收到限制，其所处于的cpu是可被抢占的
	          处于内核态的进程，可以访问所有的内存空间和对象，且所占有的cpu是不允许被抢占的
	进程运行在内核空间时,它就处于内核态;当进程运行在用户空间时,它就处于用户态
	用户态-->内核态: 系统调用，异常，中断
	整个过程：
	保留用户态现场（上下文、寄存器、用户栈等）
	用户栈切到内核栈，进入内核态
	额外的检查（内核代码对用户不信任）
	执行内核态代码
	复制内核态代码执行结果，回到用户态
	恢复用户态现场（上下文、寄存器、用户栈等）

20.进程通信详解？
	管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信
	命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建
	消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；
	信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；
	共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，**是最快的可用IPC形式。**这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥
	信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身
	内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它
	Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信

21.GIT的merge和rebase的区别? 
	1.merge合并会创建一个新的commit，rebase会在主分支最新的commit之后顺序更新。
	2.merge保留了分支的历史信息，rebase像一个分支顺序开发的
	3.merge通常用于保留项目历史的真实性，rebase用于私人开发，或者合并到公共分支时清除提交历史

22.超时重传多久传一次，一共多少次?
	超时重传时间 RTO 的值应该略大于报文往返 RTT 的值，每次超时的时间是上一次的 2 倍
	SYN的重传次数默认是5次

23.vector内存连续的好处？
	1.高效的随机访问，因为是连续的所以可以通过指针运算快速访问
	2.对缓存有好，因为是连续的所以访问一个元素时，可以把相邻的元素加载到缓存中，提高访问效率
	3.减少内存碎片，因为不会有很多小的不连续的内存

24.ddos攻击防护
	ddos是一种通过占用目标服务器的资源或使其无法正常工作来削弱或瘫痪目标网络服务的攻击方式
	1.限制不信任的ip
	2.进行负载均衡
	3.进行流量限制
25.g++ -g会保留较多的调试信息，有可能会影响程序的运行效率，那么影响的是哪部分的运行时间？ 
	可能是内存的原因，或者一些优化。
1.lc166