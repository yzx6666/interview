# TCP粘包、拆包
**TCP是“流”协议，就是没有边界的一串数据。一个完整的业务可能会被TCP拆成多个包进行发送，也有可能把多个小包封装成一个大的数据包发送，这就是TCP的粘包、拆包问题。**

## 产生原因
+   ### 拆包
    +   **待发送数据大于<font color = red>TCP发送缓冲区</font>剩余空间大小，将会发生拆包。**
    +   **带发送数据大于<font color = red>MSS</font>(TCP报文长度 - TCP头部长度 > MSS最大报文长度)，TCP在传输前根据MSS大小进行拆包分段发送。**
+   ### 粘包
    +   **待发送数据小于<font color = red>TCP发送缓冲区</font>的大小，TCP将多次写入缓冲区的数据包合并为一次发送，将发生粘包(<font color = red>Nagle</font>算法优化，避免tcp报文<font color = red>头重脚轻</font>的情况发生)**
    +   **接收端的应用层没有及时读取<font color = red>接收缓冲区</font>中的数据，将发生粘包**

## 如何解决
1.  **消息分为tcp首部和tcp消息体，<font color = red>可以通过IP首部中的总长度间接计算出：TCP数据包长度 = IP首部的数据包总长度 - IP首部长度(20字节) - TCP包首部长度(20字节)</font>。这样接收端在接收到数据后，通过读取包IP首部的总字段长度，就知道每个数据包的实际长度**
2.  **发送端在每个包的<font color = red>末尾使用固定的分隔符</font>(如 \r \n)，这样接收端通过这个边界就可以将不同的数据包拆开**
3.  **发送端将每个数据包封装成固定长度（不够的可以通过补0填充），这样接收端每次从缓冲区读取固定长度的数据就自然而然的把每个数据包拆开来。<mark>不推荐，尤其是在高并发大流量的业务场景下，会消耗不必要的资源</mark>**


## 为什么TCP有粘包
**TCP协议粘包、拆包问题是因为TCP协议传输数据是基于“字节流”的，不包含消息、数据包的概念，需要应用层协议自己设计<font color = red>消息边界</font>**

## 为什么UDP没有粘包
1.  **UDP有消息保护边界，不会发生粘包、拆包问题**
2.  **UDP发送的时候，不经过<font color = red>Nagle</font>算法优化，不会将多个小包合并成一次发送出去**
3.  **在UDP首部采用了<font color =red>16位UDP长度</font>字段来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。**
