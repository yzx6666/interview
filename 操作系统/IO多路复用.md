# I/O多路复用


## select和epoll的区别
1.  **每次调用select，都需要把fd集合拷贝到内核态，这个开销在fd很多的时候很大；而epoll保证每个fd在整个过程中只会拷贝一次。**
2.  **每次调用select都需要在内核遍历传递进来的所有fd；而epoll只需要轮询一次fd集合，同时查看就绪表中有没有就绪的fd就可以了**
3.  **select支持的文件描述符数量太小了，默认只有1024；而epoll没有这个限制，他所支持的fd上限是最大可以打开的文件数量，这个数字一般大于2048**

## epoll为什么高效
1.  **select、poll实现需要自己不断轮询所有的fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪表是否为空就行了，这节省了大量CPU时间。**
2.  **select、poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往队列上挂也只挂一次，这也节省了不少的开销。**

## I/O：
**`select、poll、epoll`都是I/O多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或写就绪），能够通知应用程序进行相应的读写操作**

## I/O多路复用的总体区别
1.  **`poll`与`select`不同，通过一个`pollfd数组`向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的`events`字段和`revents`分别用于标示关注的事件和发生的事件，故pollfd数组只被初始化一次**
2.  **`select，poll`实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而`epoll`只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。**
3.  **`select，poll`每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而`epoll`只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。**

## epoll水平触发与边缘触发的区别
- **LT模式(水平触发)下只要这个fd还有数据可读，每次`epoll_wait`都会返回他的事件，提醒用户程序去操作；**
- **而ET模式(边缘触发)中，他只会提醒一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读；**