# Linux的各种进程

## 孤儿进程：
是指一个父进程退出后，而他的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被**init进程(PID为1)**所收养，并且由init进程对他们完成状态收集工作。

<br/>

## 僵尸进程：
是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程没有调用`wait()或者waitpid()`系统调用取得子进程的终止状态，那么这个子进程描述符仍然保存在系统中，占用系统资源，这种进程被称为僵尸进程


## 如何解决僵尸进程：
1.  ### 一般，为了避免僵尸进程，在fork子进程之后我们要及时使用wait系统调用；同时子进程退出时内核会给父进程一个`SIGCHLD信号`,所以我们可以建立一个捕捉信号的信号处理函数，在函数体内用wait或（waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。
2.  ### 使用Kill命令：
    1.   `ps aux | grep Z` **进程表中所有僵尸进程的详细内容**
    2.   `kill -s SIGCHLD pid(父进程pid)`

<br/>

## 守护进程：
守护进程是运行在后台的一种生存期长的特殊进程，他独立与控制终端，处理一些系统级别任务.

## 如何实现：
1.  **创建子进程，终止父进程。方法是调用fork()产生一个子进程，然后使父进程退出。**
2.  **调用setsid()创建一个新会话**
3.  **将当前目录更改为根目录。使用fork() 创建的子进程也继承了父进程的当前工作目录。**
4.  **重设文件权限掩码。文件权限掩码是指屏蔽掉文件权限对应位**
5.  **关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符**

```c++
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <fcntl.h>  
#include <unistd.h>  
#include <sys/wait.h>  
#include <sys/types.h>  
#include <sys/stat.h>  

#define MAXFILE 65535  

int main(){  
    //第一步:创建进程   
    int pid = fork();  
    if (pid > 0)  
        exit(0);//结束父进程   
    else if (pid < 0){  
        printf("fork error!\n");  
        exit(1);//fork失败，退出   
    }  
    //第二步:子进程成为新的会话组长和进程组长,并与控制终端分离   
       setsid();  
    //第三步:改变工作目录到  
    chdir("/");  
    //第四步:重设文件创建掩模   
    umask(0);  
    //第五步:关闭打开的文件描述符  
    for (int i=0; i<MAXFILE; ++i)   
        close(i); 
        sleep(2);  
    }  
    return 0;  
}  
```