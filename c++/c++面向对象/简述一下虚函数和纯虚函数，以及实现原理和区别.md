# 简述一下虚函数和纯虚函数，以及实现原理和区别

## 虚函数
**c++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的对象，然后通过父类指针实际调用子类的成员函数。这种技术可以让父类指针有着“多种形态”，是一种泛型编程。如果调用的是非虚函数，那么无论实际对象是什么类型，都执行基类类型所定义的函数。非虚函数总是在编译阶段根据调用该函数的对象，引用或指针的类型来决定的，如果调用虚函数，则会在运行时才确定调用哪个函数，运行的虚函数是引用绑定或指针指向的对象类型定义的版本。**<br/>
**虚函数必须是基类的非静态函数** ***(原因：被static修饰的函数在编译时要求前期绑定，然而虚函数却是动态绑定，而且函数的生命周期不同)*** **。派生类可以对虚函数重新定义，但是必须具有相同的参数类型的参数个数。如果派生类没有重新定义，则它继承基类的虚函数**

<br/> 

## 虚函数实现的原理
**虚函数是通过一个虚函数表实现的，简称V-Table。在这个表中，主要是一个类的虚函数地址表，这张表解决了继承、覆盖问题，保证其内容是真实反应的函数。这样在虚函数类的实例中这个表被分配到实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这个虚函数就显得尤为重要，它像一个地图一样，指明了实际所应该调用的函数**

<br/>

## 纯虚函数
**纯虚函数是在基类中声明的虚函数，但是他在基类里没有定义。但要求所有派生类都要定义自己的实现方法。基类中实现虚函数的方法是在函数后面加 "=0"**```
virtual void GetName() = 0``` **在很多实际的情况下，基类本身生成对象显然是不合理的，例如动物类，为了解决这个问题，将函数定义成纯虚函数，则编译器要求在派生类中必须重写来实现多态性。声明纯虚函数的类被称为抽象类，她不能实例化，只能在派生类里实例化，但是派生类必须重新声明函数，否则也不能实例化**<br/>

## 抽象类为什么不能实例化
**虚函数的原理采用的Vtable（虚函数表），当类中有纯虚函数时，其虚函数表不完全，有空位。即“纯虚函数在类的vtable中对应的的表项被赋值为0，也就是指向一个不存在的函数。” 由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能实例化**

<br/>

## 抽象类的特点
1.  **抽象类只能作为基类，不能建立抽象对象**
2.  **抽象类不能做参数类型、函数返回值、或显示转换的类型**
3.  **可以定义抽象类的指针或引用，此指针可以指向它的派生类，进而实现多态性**


<br/>

## 为什么派生类必须实例化
1.  **纯虚函数是在基类中声明的虚函数，他要求任何派生类都要定义自己的实现方法，以实现多态性**
2.  **定义纯虚函数是为了实现一个接口，用来规范派生类的行为。派生类仅仅只是继承函数的接口，纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法实现一个缺省的实现，所以纯虚函数的声明就是告诉子类的设计者，“必须提供一个纯虚函数的实现，怎么实现有自己决定”**<br/>

<br/>

## 虚函数和纯虚函数的区别
1.  **含有纯虚函数的类被称为抽象类，但是只含有虚函数的不能被称为抽象类**
2.  **虚函数可以被直接使用，或者被子类重载，以多态形式调用。纯虚函数必须在子类实现，基类只是声明而没有定义**
3.  **虚函数和纯虚函数都可以被子类重载**
4.  **定义形式不同：虚函数是**```virtual{};```,**纯虚函数是**```virtual {} = 0;```

<br/>

##  虚函数表的内容什么时候写入的
1.  **虚函数表是一个存储虚函数地址的数组，以NULL结尾。虚表在编译阶段生成，对象内存空间开辟以后，写入对象的虚函数指针（vfptr），然后调用构造函数，即：虚表在构造函数之前写入**
2.  **除了构造函数之前写入外，我们还需要考虑到虚表的二次写入机制，通过这一机制每个对象的虚表指针都能准确地指向自己类的虚表，为实现多态提供支持**
